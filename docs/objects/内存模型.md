### 内存

内存其实就是连续的存储单元组成的,我们常见的额数据结构(二叉树,链表)在内存中的存储其实都是一个个安放的(物理结构),只是人为的我们赋予了不同的意义(逻辑结构).

计算机(程序)直接使用的数据保存在计算机的内存储器, 内存是cpu可以直接访问的数据存储设备,与之相对应的是外存储器.内存的基本结构是线性排列的一批存储单元,每个单元的大小相同,可以保存一个单位大小的数据,内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.

程序是以字节序列存储在文件中,在程序执行中, 对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容,例如目前常见的64位计算机,一次存取8个字节的数据, 与单元的位置或整个内存的大小无关.

在计算机内存里表示数据元素之间的联系,只有两种技术:利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置.如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.在文档管理的数学模型中,计算机处理的对象通常存在着一种最简单的线性关系, 这类数学模型可称为线性的数据结构.

python程序在运行时会先像操作系统申请线性地址,从而开辟连续的空间.不用的对象就叫垃圾,是通过gc回收机制管理的.

### python的内存模型

对象 = 确定内存空间 + 存储 

![内存模型](../img/内存.png)

### 引用计数

不用的对象就是垃圾,当对象的引用的计数器变为0的时候, 该对象可能在内存中,但是已经不能访问.python的垃圾回收不能做其他操作.如果一个对象的引用计数变为0的时候.python就去回收该对象.那么很显然python的效率会很差.那什么时候python会来回收呢?这是个好问题.

python会监听自己new了多少个新的对象和右多少对象的引用计数器变了, 两个数值做差得到的数阈值去比较,大于阈值, 内存开始进行垃圾回收,销毁引用计数器为0的对象.

优点:简单实时性, 缺点:维护引用计数消耗资源.循环引用.

### 分代回收

为了提高效率, 有很多对象, 清理了很多他依然存在,可以认为,这样的对象不需要经常回收.可以把它分到不同的集合.每个集合回收的时间间隔不同.简单的说这就是python的分代回收.

具体说一下,python中的垃圾分为1, 2, 3代.在1代里的对象每次回收都会去清理,当清理后有引用的对象依然存在, 此时他会进入2代集合.同理2代集合清理的时候存在的对象会进入2代集合.

每个集合的清理时间如何分配,会先清理1代垃圾,当清理10次一代垃圾后会清理一次2代垃圾,当清理10次2代垃圾后 会清理一次2代垃圾,当清理10次2代垃圾后会清理2代垃圾.

### 标记清除

按需分配,当内存不够的时候,从 寄存器和程序栈上的引用出发,遍历对象.将遍历的对象打上标记,然后再内存中清除没有标记的对象.

内存条是cpu可通过总线寻址,并进行读写操作的电脑部件.

内存颗粒就是内存条上的几片较大集成块，颗粒数据是每片集成块的数据，与内存容量是一个倍数关系。

Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。另外Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

### 序列化

在python中的变量都是存在内存中的,可以随时修改变量名,但是一旦程序结束,变量所占用的内存就被操作系统全部回收,如果没有把修改后的名字存储到磁盘上,下次重新运行程序,变量又被初始化了,

把变量从内存中变成可存储或传输的过程叫序列化,在python叫picking

### 大小端

所谓大端模式即是内存的低地址空间存储数据的高位，高地址空间存储数据的低位；内存由低到高访问时，首先碰到的是数据的高位，类似于将数据当做字符串；而小端模式则刚好相反.小端是低位在低字节，高位在高字节；示例： 0x12345678,在大端模式中，高位为0x12，在小端模式中，高位为0x78；注意均为1个字节.

在python3中,字符串就是unicode, Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。

### buffer

buffer, 缓冲, 缓冲就是两个模块之间的生产和消费速度不匹配,导致积压.queue就是干这个的,所以

Queue就是buffer,buffer其实就是Queue,buffer可以认为是一个队列深度很高的队列, 能容纳相当量的数据, 缓冲里的内容会在一定时间内迅速消耗掉,而不是长期呆在里面,否则就成了缓存.

数据的生产是不稳定的,可能会造成短时间数据的潮涌, 需要缓冲.

消费者消费能力不一样,有快有慢,消费者可以自己消费缓冲区中的数据,

单机时, 可以使用标准库queue模块的类来构建进程内的队列,满足多个线程间的生产消费需要.

大型系统可以使用第三方消息中间件--RabbitMQ, RocketMQ, Kafka等.

### Cache

缓存本质上是一块存储器, 追求速度的硬件中一般采用SRAM来充当,比如CPUde 各级缓存.不过追求速度的可以用DRAM来盛放.缓存可以兼顾缓冲的作用,数据往缓存里放.一般放置热点数据.经常被访问到的数据.

### Queue

队列用于两个模块之间传递消息,一般采用FIFO方式,在芯片内部，两个硬件模块（或者是CPU+固件，或者直接是组合逻辑电路）之间通常采用寄存器~寄存器对连的方式来传递数据/信号，但是寄存器对连的话，每次只能往寄存器里放一条数据，如果两端步调不一致，你处理快我处理慢的话，自然就有需求形成一个队列，那就是排布多个寄存器形成一列，然后再加上用于记录这一列寄存器中数据保存到什么位置的队列指针寄存器。生产者将消息从队列尾部入队，更新写指针，消费者从队列头部读走消息，更新读指针。队列的两个作用:解耦, 缓冲. queue类是线程安全的,适用于多线程间的安全的交换数据.内部使用了Lock 和 Condition.



