### 面向对象

**面向对象的本质就是代码重用**

面向**过程**编程，重点在于过程(可以理解成how)，即以过程为核心，计算机/写代码的人会把精力聚焦在具体的实现过程上，这个过程第一步干什么，第二步干什么，直到最后完成了你的目标。

面向**对象**编程，重点在于对象(可以理解成who)，即以对象为核心，这个对象有什么技能(不止一个技能的)，这个对象所拥有的哪些技能够帮你实现你的目标。

面向对象其实就是一种认识世界、分析世界的方法论。将万事万物抽象为各种对象。

**类class**

类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。

用计算机语言来描述类，是属性和方法的集合。

对象instance、object.

对象是类的具象，是一个实体。

对于我们每个人这个个体，都是抽象概念人类的不同的实体。

**属性：它是对象状态的抽象，用数据结构来描述。**

**操作：它是对象行为的抽象，用操作名和实现该操作的方法来描述。**



**python哲学:一切皆对象.**

**对象是数据和操作的封装**

**对象是独立的，但是对象之间可以相互作用**

目前OOP是最接近人类认知的编程范式.

面向对象3要素:

1. 封装

   组装：将数据和操作组装到一起。

   隐藏数据：对外只暴露一些接口，通过接口访问对象。比如驾驶员使用汽车，不需要了解汽车的构造细 节，只需要知道使用什么部件怎么驾驶就行，踩了油门就能跑，可以不了解其中的机动原理.

2. 继承

   多复用，继承来的就不用自己写了

   多继承少修改，OCP（Open-closed Principle），使用继承来改变，来体现个性.

- 多态

  面向对象编程最灵活的地方，动态绑定

** **

Python的类

定义:

```
class ClassName:
	语句块
1. 必须使用class关键字
2. 类名必须是用大驼峰命名
3. 类定义完成后，就产生了一个类对象，绑定到了标识符ClassName上
```

类对象及类属性

> **类对象，类的定义执行后会生成一个类对象**
>
> **类的属性，类定义中的变量和类中定义的方法都是类的属性**
>
> **类变量，上例中x是类MyClass的变量**

**self 指代当前实例本身**

> **Python类实例化后，会自动调用 \_\_init\_\_ 方法。这个方法第一个形式参数必须留给self，其它参数随意。 \_\_init\_\_方法**

```python
class MyClass:
	def __init__(self):
	print('init')
	print(MyClass) # 不会调用
	print(MyClass()) # 调用__init__
a = MyClass() # 调用__init__
```



初始化函数可以多个参数，请注意第一个位置必须是self，例如 __init__(self, name, age)

```python
class Person:

	def __init__(self, name, age):

		self.name = name

		self.age = age

	def showage(self):

		print('{} is {}'.format(self.name, self.age))

tom = Person('Tom', 20) # 实例化，会调用__init__方法并为实例进行属性的初始化

jerry = Person('Je', 25)

print(tom.name, jerry.age)

jerry.age += 1

print(jerry.age)

jerry.showage()
```

注意： __init__() 方法不能有返回值，也就是只能是return None

实例对象instance

类实例化后一定会获得一个类的实例，就是实例对象。

上例中的tom、jerry就是Person类的实例。

> **\_\_init\_\_ 方法的第一参数 self 就是指代某一个实例自身。**

类实例化后，得到一个实例对象，调用方法时采用jerry.showage()的方式，实例对象会绑定到方法上。 但是该函数签名是showage(self)，少传一个实际参数self吗？

这个self就是jerry，jerry.showage()调用时，会把方法的调用者jerry实例作为第一参数self的实参传入。 self.name就是jerry对象的name，name是保存在了jerry对象上，而不是Person类上。所以，称为实例变量。

实例属性的查找顺序:

指的是实例使用 .点号 来访问属性，会先找自己的 __dict__ ，如果没有，然后通过属性 __class__ 找到自己的 类，再去类的 __dict__ 中找

注意：如果实例使用 __dict__[变量名] 访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的key 查找，不是属性查找。

一般来说，类变量可使用全大写来命名。

** **
