![](media/image1.jpg)

> **Python装饰器**
>
> **讲师：Wayne**
>
> **从业十余载，漫漫求知路**

![](media/image4.jpg)

**装饰器**

** 需求**

> ** 一个加法函数，想增强它的功能，能够输出被调用过以及调用的参数信息**
>
> **def add(x, y):**
>
> **return x + y**
>
> **增加信息输出功能**
>
> **def add(x, y):**
>
> **print(\"call add, x + y\") \# 日志输出到控制台**
>
> **return x + y**
>
> ** 上面的加法函数是完成了需求，但是有以下的缺点**
>
> ** 打印是一个功能，这条语句和add函数耦合太高**
>
> ** 加法函数属于业务功能，而输出信息的功能，属于非业务功能代码，不该放在 业务函数add中**

![](media/image7.jpg)

**装饰器**

> ** 下面代码做到了业务功能分离，但是 fn函数调用传参是个问题 def add(x,y):**
>
> **return x + y**
>
> **def logger(fn):**
>
> **print(\'begin\') \# 增强的输出**
>
> **x = fn(4,5)**
>
> **print(\'end\') \# 增强的功能**
>
> **return x**
>
> **print(logger(add))**

![](media/image10.jpg)

**装饰器**

> ** 解决了传参的问题，进一步改变 def add(x,y):**
>
> **return x + y**
>
> **def logger(fn,\*args,\*\*kwargs):**
>
> **print(\'begin\')**
>
> **x = fn(\*args,\*\*kwargs)**
>
> **print(\'end\')**
>
> **return x**
>
> **print(logger(add,5,y=60))**

![](media/image13.jpg)

**装饰器**

** 柯里化**

> **def add(x,y):**
>
> **return x + y**
>
> **def logger(fn):**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **print(\'begin\')**
>
> **x = fn(\*args,\*\*kwargs)**
>
> **print(\'end\')**
>
> **return x**
>
> **return wrapper**
>
> **print(logger(add)(5,y=50))**

**换一种写法 add = logger(add)**

**print(add(x=5, y=10))**

![](media/image16.jpg)

**装饰器**

** 装饰器语法糖**

> **def logger(fn):**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **print(\'begin\')**
>
> **x = fn(\*args,\*\*kwargs)**
>
> **print(\'end\')**
>
> **return x**
>
> **return wrapper**
>
> **\@logger \# 等价于add = logger(add) def add(x,y):**
>
> **return x + y**
>
> **print(add(45,40))**

** \@logger 是什么？这就是装饰器语法**

![](media/image19.jpg)

**装饰器**

** 装饰器（无参）**

> ** 它是一个函数**
>
> ** 函数作为它的形参。无参装饰器实际上就是一个单形参函数**
>
> ** 返回值也是一个函数**
>
> ** 可以使用\@functionname方式，简化调用**

**注：此处装饰器的定义只是就目前所学的总结，并不准确，只是方便理解  装饰器和高阶函数**

> ** 装饰器可以是高阶函数，但装饰器是对传入函数的功能的装饰（功能增强）**

![](media/image22.jpg)

> **装饰器**
>
> **import datetime**
>
> **import time**
>
> **def logger(fn):**
>
> **def wrapper(\*args, \*\*kwargs):**
>
> **\# before 功能增强**
>
> **print(\"args={}, kwargs={}\".format(args,kwargs))**
>
> **start = datetime.datetime.now() \# 计算时长**
>
> **ret = fn(\*args, \*\*kwargs)**
>
> **\# after 功能增强**
>
> **duration = datetime.datetime.now() - start**
>
> **print(\"function {} took {}s.\".format(fn.\_\_name\_\_, duration.total\_seconds())) return ret**
>
> **return wrapper**

**\@logger \# 相当于 add = logger(add)**

> **def add(x, y):**
>
> **print(\"===call add===========\")**
>
> **time.sleep(2)**
>
> **return x + y**
>
> **print(add(4, y=7))**

![](media/image25.jpg)

**装饰器**

** 怎么理解装饰器呢？**

![](media/image31.jpg)

**文档字符串**

** Python的文档**

> ** Python文档字符串Documentation Strings**
>
> ** 在函数语句块的第一行，且习惯是多行的文本，所以多使用三引号  惯例是首字母大写，第一行写概述，空一行，第三行写详细描述  可以使用特殊属性\_\_doc\_\_访问这个文档**
>
> **def add(x,y):**
>
> **\"\"\"This is a function of addition\"\"\"**
>
> **return x + y**
>
> **print(\"name={}\\ndoc={}\".format(add.\_\_name\_\_, add.\_\_doc\_\_))**
>
> **print(help(add))**

![](media/image34.jpg)

**装饰器**

** 副作用**

> **def logger(fn):**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **\'I am wrapper\'**
>
> **print(\'begin\')**
>
> **x = fn(\*args,\*\*kwargs)**
>
> **print(\'end\')**
>
> **return x**
>
> **return wrapper**
>
> **\@logger \#add = logger(add)**
>
> **def add(x,y):**
>
> **\'\'\'This is a function for add\'\'\'**
>
> **return x + y**
>
> **print(\"name={}, doc={}\".format(add.\_\_name\_\_, add.\_\_doc\_\_))**

** 原函数对象的属性都被替换了，而使用装饰器，我们的需求是查看被封装函数的属性，如何解决？**

![](media/image37.jpg)

**装饰器**

> ** 提供一个函数，被封装函数属性 ==copy==\> 包装函数属性 def copy\_properties(src, dst): \# 可以改造成装饰器**
>
> **dst.\_\_name\_\_ = src.\_\_name\_\_**
>
> **dst.\_\_doc\_\_ = src.\_\_doc\_\_**
>
> **def logger(fn):**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **\'I am wrapper\'**
>
> **print(\'begin\')**
>
> **x = fn(\*args,\*\*kwargs)**
>
> **print(\'end\')**
>
> **return x**
>
> **copy\_properties(fn, wrapper)**
>
> **return wrapper**
>
> **\@logger \#add = logger(add)**
>
> **def add(x,y):**
>
> **\'\'\'This is a function for add\'\'\'**
>
> **return x + y**
>
> **print(\"name={}, doc={}\".format(add.\_\_name\_\_, add.\_\_doc\_\_))**

![](media/image40.jpg)

**装饰器**

** 通过copy\_properties函数将被包装函数的属性覆盖掉包装函数  凡是被装饰的函数都需要复制这些属性，这个函数很通用  可以将复制属性的函数构建成装饰器函数，带参装饰器**

![](media/image43.jpg)

**装饰器**

> ** 提供一个函数，被封装函数属性 ==copy==\> 包装函数属性，改造成带参装饰器 def copy\_properties(src): \# 柯里化**
>
> **def \_copy(dst):**
>
> **dst.\_\_name\_\_ = src.\_\_name\_\_**
>
> **dst.\_\_doc\_\_ = src.\_\_doc\_\_**
>
> **return dst**
>
> **return \_copy**
>
> **def logger(fn):**
>
> **\@copy\_properties(fn) \# wrapper = copy\_properties(fn)(wrapper)**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **\'I am wrapper\'**
>
> **print(\'begin\')**
>
> **x = fn(\*args,\*\*kwargs)**
>
> **print(\'end\')**
>
> **return x**
>
> **return wrapper**
>
> **\@logger \#add = logger(add)**
>
> **def add(x,y):**
>
> **\'\'\'This is a function for add\'\'\'**
>
> **return x + y**
>
> **print(\"name={}, doc={}\".format(add.\_\_name\_\_, add.\_\_doc\_\_))**

![](media/image46.jpg)

**带参装饰器**

> ** 需求：获取函数的执行时长，对时长超过阈值的函数记录一下 def logger(duration):**
>
> **def \_logger(fn):**
>
> **\@copy\_properties(fn) \# wrapper = wrapper(fn)(wrapper) def wrapper(\*args,\*\*kwargs):**
>
> **start = datetime.datetime.now()**
>
> **ret = fn(\*args,\*\*kwargs)**
>
> **delta = (datetime.datetime.now() - start).total\_seconds() print(\'so slow\') if delta \> duration else print(\'so fast\') return ret**
>
> **return wrapper**
>
> **return \_logger**
>
> **\@logger(5) \# add = logger(5)(add)**
>
> **def add(x,y):**
>
> **time.sleep(3)**
>
> **return x + y**
>
> **print(add(5, 6))**

![](media/image49.jpg)

**带参装饰器**

** 带参装饰器**

> ** 它是一个函数**
>
> ** 函数作为它的形参**
>
> ** 返回值是一个不带参的装饰器函数**
>
> ** 使用\@functionname(参数列表)方式调用**
>
> ** 可以看做在装饰器外层又加了一层函数，这个函数可以多参数**

![](media/image52.jpg)

**带参装饰器**

** 将记录的功能提取出来，这样就可以通过外部提供的函数来灵活的控制输出**

> **def logger(duration, func=lambda name, delta: print(\'{} took {:.2f}s\'.format(name, delta))): def \_logger(fn):**
>
> **\@copy\_properties(fn) \# wrapper = wrapper(fn)(wrapper)**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **start = datetime.datetime.now()**
>
> **ret = fn(\*args,\*\*kwargs)**
>
> **delta = (datetime.datetime.now() - start).total\_seconds()**
>
> **if delta \> duration:**
>
> **func(fn.\_\_name\_\_, delta)**
>
> **return ret**
>
> **return wrapper**
>
> **return \_logger**

![](media/image55.jpg)

**functools模块**

** functools.update\_wrapper(wrapper, wrapped, assigned=WRAPPER\_ASSIGNMENTS,**

> **updated=WRAPPER\_UPDATES)**
>
> ** 类似copy\_properties功能**
>
> ** wrapper 包装函数、被更新者，wrapped 被包装函数、数据源**
>
> ** 元组WRAPPER\_ASSIGNMENTS中是要被覆盖的属性**
>
> **\'\_\_module\_\_\', \'\_\_name\_\_\', \'\_\_qualname\_\_\', \'\_\_doc\_\_\', \'\_\_annotations\_\_\'**
>
> **模块名、名称、限定名、文档、参数注解**
>
> ** 元组WRAPPER\_UPDATES中是要被更新的属性，\_\_dict\_\_属性字典**
>
> ** 增加一个\_\_wrapped\_\_属性，保留着wrapped函数**

![](media/image58.jpg)

**functools模块**

> **import datetime, time, functools**
>
> **def logger(duration, func=lambda name, duration: print(\'{} took {}s\'.format(name, duration))): def \_logger(fn):**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **start = datetime.datetime.now()**
>
> **ret = fn(\*args,\*\*kwargs)**
>
> **delta = (datetime.datetime.now() - start).total\_seconds()**
>
> **if delta \> duration:**
>
> **func(fn.\_\_name\_\_, duration)**
>
> **return ret**
>
> **return functools.update\_wrapper(wrapper, fn)**
>
> **return \_logger**
>
> **\@logger(5) \# add = logger(5)(add)**
>
> **def add(x,y):**
>
> **time.sleep(1)**
>
> **return x + y**
>
> **print(add(5, 6), add.\_\_name\_\_, add.\_\_wrapped\_\_, add.\_\_dict\_\_, sep=\'\\n\')**

![](media/image61.jpg)

**functools模块**

** \@functools.wraps(wrapped, assigned=WRAPPER\_ASSIGNMENTS,**

> **updated=WRAPPER\_UPDATES)**
>
> ** 类似copy\_properties功能**
>
> ** wrapped 被包装函数**
>
> ** 元组WRAPPER\_ASSIGNMENTS中是要被覆盖的属性**
>
> **\'\_\_module\_\_\', \'\_\_name\_\_\', \'\_\_qualname\_\_\', \'\_\_doc\_\_\', \'\_\_annotations\_\_\' 模块名、名称、限定名、文档、参数注解**
>
> ** 元组WRAPPER\_UPDATES中是要被更新的属性，\_\_dict\_\_属性字典  增加一个\_\_wrapped\_\_属性，保留着wrapped函数**

![](media/image64.jpg)

**functools模块**

> **import datetime, time, functools**
>
> **def logger(duration, func=lambda name, duration: print(\'{} took {}s\'.format(name, duration))): def \_logger(fn):**
>
> **\@functools.wraps(fn)**
>
> **def wrapper(\*args,\*\*kwargs):**
>
> **start = datetime.datetime.now()**
>
> **ret = fn(\*args,\*\*kwargs)**
>
> **delta = (datetime.datetime.now() - start).total\_seconds()**
>
> **if delta \> duration:**
>
> **func(fn.\_\_name\_\_, duration)**
>
> **return ret**
>
> **return wrapper**
>
> **return \_logger**
>
> **\@logger(5) \# add = logger(5)(add)**
>
> **def add(x,y):**
>
> **time.sleep(1)**
>
> **return x + y**
>
> **print(add(5, 6), add.\_\_name\_\_, add.\_\_wrapped\_\_, add.\_\_dict\_\_, sep=\'\\n\')**

![](media/image67.jpg)

**functools模块**

** 右边的程序**

> ** logger什么时候执行？**
>
> ** logger执行过几次？**
>
> ** wraps装饰器执行过几次？**
>
> ** wrapper的\_\_name\_\_等属性被覆盖过几次？  add.\_\_name\_\_ 打印什么名称？**
>
> ** sub.\_\_name\_\_ 打印什么名称？**

**import datetime, functools**

**def logger(fn):**

> **\@functools.wraps(fn)**
>
> **def wrapper(\*args, \*\*kwargs):**
>
> **start = datetime.datetime.now()**
>
> **ret = fn(\*args, \*\*kwargs)**
>
> **delta = (datetime.datetime.now() - start).total\_seconds() if delta \> 3: print(\'too slow\')**
>
> **return ret**
>
> **return wrapper**

**\@logger**

**def add(x, y): pass**

**\@logger**

**def sub(x, y): pass**

**print(add.\_\_name\_\_, sub.\_\_name\_\_)**

![](media/image70.jpg)

> **谢谢**
>
> **咨询热线 400-080-6560**
