

特殊属性

> **属性**
>
> **\_\_name\_\_**
>
> **\_\_module\_\_**
>
> **\_\_class\_\_**
>
> **\_\_bases\_\_**
>
> **\_\_doc\_\_**
>
> **\_\_mro\_\_**
>
> **\_\_dict\_\_**

查看属性

> 方法
>
> **\_\_dir\_\_**

含义

类、函数、方法等的名字

类定义所在的模块名

对象或类所属的类

类的基类的元组，顺序为它们在基类列表中出现的顺序 类、函数的文档字符串，如果没有定义则为None 类的mro，class.mro()返回的结果的保存在 __mro__ 中 类或实例的属性，可写的字典

> **意义**
>
> **返回类或者对象的所有成员名称列表。**
>
> **dir()函数操作实例就是调用 \_\_dir\_\_ ()。**

  __dir__   方
----------------- -----------------
  有            __dir__



> **self.\_name = name self.\_\_age = 10 self.weight = 20**

print('animal Module\'s names # cat.py

import animal

from animal import Animal class Cat(Animal):

> **x = \'cat\'**
>
> **y = \'abcd\'**

class Dog(Animal):

> **def \_\_dir\_\_(self):**

= {}'.format(dir())) # 模块的属性

> **return \[\'dog\'\] \# 必须返回可迭代对象**

print('---------')

print('Current Module\'s names = {}'.format(dir())) # 模块名词空间内的属性

print('animal Module\'s names print("object's __dict__

= {}'.format(dir(animal))) # 指定模块名词空间内的属性

= {}".format(sorted(object.__dict__.keys()))) # object的字典

print("Animal's dir() = {}".format(dir(Animal))) # 类Animal的dir()

print("Cat's dir()

= {}".format(dir(Cat))) # 类Cat的dir()

print('~~~~~~~~~')

tom = Cat('tom')

print(sorted(dir(tom))) # 实例tom的属性、Cat类及所有祖先类的类属性

print(sorted(tom.__dir__())) # 同上

# dir()的等价 近似如下，__dict__字典中几乎包括了所有属性

print(sorted(set(tom.__dict__.keys()) | set(Cat.__dict__.keys()) | set(object.__dict__.keys()))) print("Dog's dir = {}".format(dir(Dog)))

dog = Dog('snoppy')

print(dir(dog))

print(dog.__dict__)

# 执行结果

animal Module's names

= ['Animal', '__builtins__', '__cached__', '__doc__', '__file__',

'__loader__', '__name__', '__package__', '__spec__']

---------

Current Module's names = ['Animal', ' Cat', 'Dog', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'animal']

animal Module's names

= ['Animal', '__builtins__', '__cached__', '__doc__', '__file__',

'__loader__', '__name__', '__package__', '__spec__']

object's __dict__

= ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__',

> **\'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\', \'\_\_lt\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\', \'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\'\]**
>
> **Animal\'s dir() = \[\'\_\_class\_\_\', \'\_\_delattr\_\_\', \'\_\_dict\_\_\', \'\_\_dir\_\_\', \'\_\_doc\_\_\', \'\_\_eq\_\_\', \'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\', \'\_\_lt\_\_\', \'\_\_module\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\', \'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\', \'\_\_weakref\_\_\', \'x\'\]**



> **Cat\'s dir()**

= ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__',

> **\'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\',**
>
> **\'\_\_lt\_\_\', \'\_\_module\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\',**
>
> **\'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\', \'\_\_weakref\_\_\', \'x\', \'y\'\] \~\~\~\~\~\~\~\~\~**
>
> **\[\'\_Animal\_\_age\', \'\_\_class\_\_\', \'\_\_delattr\_\_\', \'\_\_dict\_\_\', \'\_\_dir\_\_\', \'\_\_doc\_\_\', \'\_\_eq\_\_\', \'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\', \'\_\_lt\_\_\', \'\_\_module\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\', \'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\', \'\_\_weakref\_\_\', \'\_name\', \'weight\', \'x\', \'y\'\]**
>
> **\[\'\_Animal\_\_age\', \'\_\_class\_\_\', \'\_\_delattr\_\_\', \'\_\_dict\_\_\', \'\_\_dir\_\_\', \'\_\_doc\_\_\', \'\_\_eq\_\_\', \'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\', \'\_\_lt\_\_\', \'\_\_module\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\', \'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\', \'\_\_weakref\_\_\', \'\_name\', \'weight\', \'x\', \'y\'\]**
>
> **\[\'\_Animal\_\_age\', \'\_\_class\_\_\', \'\_\_delattr\_\_\', \'\_\_dir\_\_\', \'\_\_doc\_\_\', \'\_\_eq\_\_\', \'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\', \'\_\_lt\_\_\', \'\_\_module\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\', \'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\', \'\_name\', \'weight\', \'x\', \'y\'\]**
>
> **Dog\'s dir = \[\'\_\_class\_\_\', \'\_\_delattr\_\_\', \'\_\_dict\_\_\', \'\_\_dir\_\_\', \'\_\_doc\_\_\', \'\_\_eq\_\_\',**
>
> **\'\_\_format\_\_\', \'\_\_ge\_\_\', \'\_\_getattribute\_\_\', \'\_\_gt\_\_\', \'\_\_hash\_\_\', \'\_\_init\_\_\', \'\_\_le\_\_\',**
>
> **\'\_\_lt\_\_\', \'\_\_module\_\_\', \'\_\_ne\_\_\', \'\_\_new\_\_\', \'\_\_reduce\_\_\', \'\_\_reduce\_ex\_\_\', \'\_\_repr\_\_\',**
>
> **\'\_\_setattr\_\_\', \'\_\_sizeof\_\_\', \'\_\_str\_\_\', \'\_\_subclasshook\_\_\', \'\_\_weakref\_\_\', \'x\'\]**
>
> **\[\'dog\'\]**
>
> **{\'\_Animal\_\_age\': 10, \'weight\': 20, \'\_name\': \'snoppy\'}**

dir()的测试如下

> **class Person:**
>
> **def show(self): \# 方法中**
>
> **a = 100**
>
> **t = int(a)**
>
> **print(dir())**
>
> **print(locals())**
>
> **def test(a=50, b=100): \# 函数中**
>
> **c = 150**
>
> **print(dir())**
>
> **print(locals())**
>
> **Person().show()**
>
> **test()**
>
> **print(dir())**
>
> **print(sorted(locals().keys()))**
>
> **print(sorted(globals().keys()))**
>
> **\# 显示结果如下**
>
> **\[\'a\', \'self\', \'t\'\]**
>
> **{\'t\': 100, \'a\': 100, \'self\': \<\_\_main\_\_.Person object at 0x0000026EA752EB38\>}**
>
> **\[\'a\', \'b\', \'c\'\]**



> **{\'c\': 150, \'b\': 100, \'a\': 50}**
>
> **\[\'Person\', \'\_\_annotations\_\_\', \'\_\_builtins\_\_\', \'\_\_cached\_\_\', \'\_\_doc\_\_\', \'\_\_file\_\_\', \'\_\_loader\_\_\', \'\_\_name\_\_\', \'\_\_package\_\_\', \'\_\_spec\_\_\', \'test\'\]**
>
> **\[\'Person\', \'\_\_annotations\_\_\', \'\_\_builtins\_\_\', \'\_\_cached\_\_\', \'\_\_doc\_\_\', \'\_\_file\_\_\', \'\_\_loader\_\_\', \'\_\_name\_\_\', \'\_\_package\_\_\', \'\_\_spec\_\_\', \'test\'\]**
>
> **\[\'Person\', \'\_\_annotations\_\_\', \'\_\_builtins\_\_\', \'\_\_cached\_\_\', \'\_\_doc\_\_\', \'\_\_file\_\_\', \'\_\_loader\_\_\', \'\_\_name\_\_\', \'\_\_package\_\_\', \'\_\_spec\_\_\', \'test\'\]**

内建函数

> **locals() 返回当前作用域中的变量字典**
>
> **globals() 当前模块全局变量的字典**

** **

魔术方法 ***

> **分类：**
>
> **创建、初始化与销毁**
>
> **\_\_new\_\_**
>
> **\_\_init\_\_ 与 \_\_del\_\_**
>
> **可视化**
>
> **hash**
>
> **bool**
>
> **运算符重载**
>
> **容器和大小**
>
> **可调用对象**
>
> **上下文管理**
>
> **反射**
>
> **描述器**
>
> **其他杂项**

** **

实例化

> **方法**
>
> **\_\_new\_\_**
>
> **class A:**

意义

实例化一个对象

该方法需要返回一个值，如果该值不是cls的实例，则不会调用 __init__ 该方法永远都是静态方法

> **def \_\_new\_\_(cls, \*args, \*\*kwargs): print(cls)**



> **print(args)**
>
> **print(kwargs)**
>
> **\#return super().\_\_new\_\_(cls)**
>
> **\#return 1**
>
> **return None**
>
> **def \_\_init\_\_(self, name):**
>
> **self.name = name**
>
> **a = A()**
>
> **print(a)**

__new__ 方法很少使用，即使创建了该方法，也会使用 return super().__new__(cls) 基类object的 __new__ 方 法来创建实例并返回。

** **

可视化

> **方法**
>
> **\_\_str\_\_**
>
> **\_\_repr\_\_**
>
> **\_\_bytes\_\_**
>
> **class A:**

意义

str()函数、format()函数、print()函数调用，需要返回对象的字符串表达。如果没有定义，就 去调用 __repr__ 方法返回字符串表达，如果 __repr__ 没有定义，就直接返回对象的内存地 址信息

内建函数repr()对一个对象获取字符串表达。

调用 __repr__ 方法返回字符串表达，如果 __repr__ 也没有定义，就直接返回object的定义 就是显示内存地址信息

bytes()函数调用，返回一个对象的bytes表达，即返回bytes对象

> **def \_\_init\_\_(self, name, age=18):**
>
> **self.name = name**
>
> **self.age = age**
>
> **def \_\_repr\_\_(self):**
>
> **return \'repr: {},{}\'.format(self.name, self.age) def \_\_str\_\_(self):**
>
> **return \'str:**

{},{}'.format(self.name, self.age)

> **def \_\_bytes\_\_(self):**
>
> **\#return \"{} is {}\".format(self.name, self.age).encode() import json**
>
> **return json.dumps(self.\_\_dict\_\_).encode()**
>
> **print(A(\'tom\')) \# print函数使用\_\_str\_\_**
>
> **print(\'{}\'.format(A(\'tom\')))**
>
> **print(\[A(\'tom\')\]) \# \[\]使用\_\_str\_\_，但其内部使用\_\_repr\_\_**



> **print(\[str(A(\'tom\'))\]) \# \[\]使用\_\_str\_\_，其中的元素使用str()函数也调用\_\_str\_\_ print(\'str:a,1\') \# 字符串直接输出没有引号**
>
> **s = \'1\'**
>
> **print(s)**
>
> **s1 = \'a\'**
>
> **print(s1)**
>
> **print(\[s1\],(s,)) \# 字符串在基本数据类型内部输出有引号**
>
> **print({s, \'a\'})**
>
> **print(bytes(A(\'tom\')))**

注意不能通过判断是否带引号来判断输出值的类型，类型判断要使用type或isinstance  

hash

> **方法**
>
> **\_\_hash\_\_**

意义

内建函数 hash() 调用的返回值，返回一个整数。如果定义这个方法该类的实例就可hash。

> **print(hash(1))**
>
> **print(hash(\'tom\'))**
>
> **print(hash((\'tom\',)))**
>
> **class A:**
>
> **def \_\_init\_\_(self, name, age=18): self.name = name**
>
> **def \_\_hash\_\_(self):**
>
> **return 1**
>
> **def \_\_repr\_\_(self):**
>
> **return self.name**
>
> **print(hash(A(\'tom\')))**
>
> **print((A(\'tom\'), A(\'tom\')))**
>
> **print(\[A(\'tom\'), A(\'tom\')\])**
>
> **print(\'\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\')**
>
> **print({1, 1})**
>
> **a1 = A(\'tom\')**
>
> **a2 = A(\'tom\')**
>
> **s = {a1, a2} \# set**
>
> **print(s) \# 去重了吗**
>
> **print(hash(a1), hash(a2))**
>
> **t1 = (\'tom\',)**



> **t2 = (\'tom\',)**
>
> **print(t1 is t2)**
>
> **print(t1 == t2)**
>
> **print({t1, t2}, hash(t1), hash(t2))**
>
> **print({(\'tom\',), (\'tom\',)})**
>
> **print({\'tom\', \'tom\'})**

上例中， A的实例放在set中，它们hash值是相同的，为什么不能去重？ hash值相同就会去重吗？

> **class A:**
>
> **def \_\_init\_\_(self, name, age=18):**
>
> **self.name = name**
>
> **def \_\_hash\_\_(self):**
>
> **return 1**
>
> **def \_\_eq\_\_(self, other): \# 这个函数作用？**
>
> **return self.name == other.name**
>
> **def \_\_repr\_\_(self):**
>
> **return self.name**
>
> **print(hash(A(\'tom\')))**
>
> **print((A(\'tom\'), A(\'tom\')))**
>
> **print(\[A(\'tom\'), A(\'tom\')\])**
>
> **print(\'\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\')**
>
> **s = {A(\'tom\'), A(\'tom\')} \# set**
>
> **print(s)**
>
> **方法**
>
> **\_\_eq\_\_**

意义

对应==操作符，判断2个对象是否相等，返回bool值

定义了这个方法，如果不提供 __hash__ 方法，那么实例将不可hash了

__hash__ 方法只是返回一个hash值作为set的key，但是 去重 ，还需要 __eq__ 来判断2个对象是否相等。 hash值相等，只是hash冲突，不能说明两个对象是相等的。

因此，一般来说提供 __hash__ 方法是为了作为set或者dict的key，如果 去重 要同时提供 __eq__ 方法。 不可hash对象isinstance(p1, collections.Hashable)一定为False。

> **去重 需要提供 \_\_eq\_\_ 方法。**

思考：

> **1. list类实例为什么不可hash？**
>
> **2. functools.lru\_cache使用到的functools.\_HashedSeq类继承自list，为什么可hash？**

练习

设计二维坐标类Point，使其成为可hash类型，并比较2个坐标的实例是否相等？



** **

> **1. list类实例为什么不可hash**
>
> **源码中有一句 \_\_hash\_\_ = None，也就是如果调用 \_\_hash\_\_ ()相当于None()，一定报错。**
>
> **所有类都继承object，而这个类是具有 \_\_hash\_\_ ()方法的，如果一个类不能被hash，就把 \_\_hash\_\_ 设置为 None。**
>
> **2. \_HashedSeq类提供了\_\_hash\_\_方法，这个方法实际上计算的是元组的hash值**

** **

练习参考

> **from collections import Hashable**
>
> **class Point:**
>
> **def \_\_init\_\_(self, x, y):**
>
> **self.x = x**
>
> **self.y = y**
>
> **def \_\_hash\_\_(self):**
>
> **return hash((self.x, self.y))**
>
> **def \_\_eq\_\_(self, other):**
>
> **return self.x == other.x and self.y == other.y**
>
> **p1 = Point(4, 5)**
>
> **p2 = Point(4, 5)**
>
> **print(hash(p1))**
>
> **print(hash(p2))**
>
> **print(p1 is p2)**
>
> **print(p1 == p2) \# True 使用\_\_eq\_\_**
>
> **print(hex(id(p1)), hex(id(p2)))**
>
> **print(set((p1, p2)))**
>
> **print(isinstance(p1, Hashable))**

** **

bool

> **方法**
>
> **\_\_bool\_\_**

  定义          __bool__
----------------- ------------------
  __len__   ()也

> **class A: pass**
>
> **print(bool(A()))**



> **if A():**
>
> **print(\'Real A\')**
>
> **class B:**
>
> **def \_\_bool\_\_(self):**
>
> **return False**
>
> **print(bool(B))**
>
> **print(bool(B()))**
>
> **if B():**
>
> **print(\'Real B\')**
>
> **class C:**
>
> **def \_\_len\_\_(self):**
>
> **return 0**
>
> **print(bool(C()))**
>
> **if C():**
>
> **print(\'Real C\')**

** **

运算符重载

operator模块提供以下的特殊方法，可以将类的实例使用下面的操作符来操作

+--------------------------------------+-------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------+
| 运算符                           | 特殊方法                                                                                                                  | 含义                                    |
+======================================+===============================================================================================================================+=============================================+
| <, <=, ==, >,                 | __lt__ , __le__ , __eq__ , __gt__ , __ge__ , __ne__                                               | 比较运算符                              |
|                                      |                                                                                                                               |                                             |
| >=, !=                          |                                                                                                                               |                                             |
+--------------------------------------+-------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------+
| +, -, *, /, %, //, **, divmod | __add__ , __sub__ , __mul__ , __truediv__ , __mod__ , __floordiv__ , __pow__ , __divmod__ | 算数运算符，移位、位运 算也有对应的方法 |
+--------------------------------------+-------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------+
| +=, -=, *=, /=,                 | __iadd__ , __isub__ , __imul__ , __itruediv__ , __imod__ , __ifloordiv__ , __ipow__           | ** **                                       |
|                                      |                                                                                                                               |                                             |
| %=, //=, **=                   |                                                                                                                               |                                             |
+--------------------------------------+-------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------+

实现A类的2个实例相减

> **class A:**
>
> **def \_\_init\_\_(self, name, age=18):**
>
> **self.name = name**
>
> **self.age = age**
>
> **def \_\_sub\_\_(self, other):**
>
> **return self.age - other.age**
>
> **def \_\_isub\_\_(self, other): \# 如果没有定义\_\_isub\_\_，则会调用\_\_sub\_\_ return A(self.name, self - other)**
>
> **tom = A(\'tom\')**



> **jerry = A(\'jerry\', 16)**
>
> **print(tom - jerry)**
>
> **print(jerry - tom, jerry.\_\_sub\_\_(tom))**
>
> **print(id(tom))**
>
> **tom -= jerry**
>
> **print(tom.age, id(tom))**
>
> **\_\_isub\_\_ 方法定义，一般会in-place就地来修改自身**

如果没有定义 __isub__ 方法，则会调用 __sub__

练习：

完成Point类设计，实现判断点相等的方法，并完成向量的加法

在直角坐标系里面，定义原点为向量的起点。两个向量和与差的坐标分别等于这两个向量相应坐标的和与差若向量 的表示为(x,y)形式,

> **A(X1,Y1) B(X2,Y2)，则A+B=（X1+X2，Y1+Y2），A -B=（X1-X2，Y1-Y2）**

** **

> **class Point:**
>
> **def \_\_init\_\_(self, x, y):**
>
> **self.x = x**
>
> **self.y = y**
>
> **def \_\_eq\_\_(self, other):**
>
> **return self.x == other.x and self.y == other.y**
>
> **def \_\_add\_\_(self, other):**
>
> **return Point(self.x + other.x, self.y + other.y)**
>
> **def add(self, other):**
>
> **return (self.x + other.x, self.y + other.y)**
>
> **def \_\_str\_\_(self):**
>
> **return \'\<Point: {},{}\>\'.format(self.x, self.y)**
>
> **p1 = Point(1,1)**
>
> **p2 = Point(1,1)**
>
> **print(p1.add(p2))**
>
> **\# 运算符重载**
>
> **print(p1 + p2)**
>
> **print(p1 == p2)**

运算符重载应用场景



往往是用面向对象实现的类，需要做大量的运算，而运算符是这种运算在数学上最常见的表达方式。例如，上例中 的对+进行了运算符重载，实现了Point类的二元操作，重新定义为Point + Point。

提供运算符重载，比直接提供加法方法要更加适合该领域内使用者的习惯。

int类，几乎实现了所有操作符，可以作为参考。

\@functools.total_ordering 装饰器

__lt__ , __le__ , __eq__ , __gt__ , __ge__ 是比较大小必须实现的方法，但是全部写完太麻烦，使用 \@functools.total_ordering 装饰器就可以大大简化代码。

但是要求 __eq__ 必须实现，其它方法 __lt__ , __le__ , __gt__ , __ge__ 实现其一

> **from functools import total\_ordering**
>
> **\@total\_ordering**
>
> **class Person:**
>
> **def \_\_init\_\_(self, name, age):**
>
> **self.name = name**
>
> **self.age = age**
>
> **def \_\_eq\_\_(self, other):**
>
> **return self.age == other.age**
>
> **def \_\_gt\_\_(self, other):**
>
> **return self.age \> other.age**
>
> **tom = Person(\'tom\', 20)**
>
> **jerry = Person(\'jerry\', 16)**
>
> **print(tom \> jerry)**
>
> **print(tom \< jerry)**
>
> **print(tom \>= jerry) \#**
>
> **print(tom \<= jerry) \#**

上例中大大简化代码，但是一般来说比较实现等于或者小于方法也就够了，其它可以不实现，所以这个装饰器只是 看着很美好，且可能会带来性能问题，建议需要什么方法就自己创建，少用这个装饰器。

> **class Person:**
>
> **def \_\_init\_\_(self, name, age):**
>
> **self.name = name**
>
> **self.age = age**
>
> **def \_\_eq\_\_(self, other):**
>
> **return self.age == other.age**
>
> **def \_\_gt\_\_(self, other):**
>
> **return self.age \> other.age**
>
> **def \_\_ge\_\_(self, other):**
>
> **return self.age \>= other.age**



> **tom = Person(\'tom\', 20)**
>
> **jerry = Person(\'jerry\', 16)**
>
> **print(tom \> jerry)**
>
> **print(tom \< jerry)**
>
> **print(tom \>= jerry) \#**
>
> **print(tom \<= jerry)**
>
> **print(tom == jerry)**
>
> **print(tom != jerry)**
>
> **\_\_eq\_\_ 等于可以推断不等于**
>
> **\_\_gt\_\_ 大于可以推断小于**
>
> **\_\_ge\_\_ 大于等于可以推断小于等于**

也就是用3个方法，就可以把所有比较解决了，所以total_ordering可以不使用  

容器相关方法

> **方法**
>
> **\_\_len\_\_**
>
> **\_\_iter\_\_**
>
> **\_\_contains\_\_**
>
> **\_\_getitem\_\_**
>
> **\_\_setitem\_\_**
>
> **\_\_missing\_\_**
>
> **class A(dict):**

意义

内建函数len()，返回对象的长度（>=0的整数），如果把对象当做容器类型看，就如同list 或者dict。

> **bool()函数调用的时候，如果没有 \_\_bool\_\_() 方法，则会看 \_\_len\_\_() 方法是否存在， 存在返回非0为真**

迭代容器时，调用，返回一个新的迭代器对象

in 成员运算符，没有实现，就调用 __iter__ 方法遍历

实现self[key]访问。序列对象，key接受整数为索引，或者切片。对于set和dict，key为 hashable。key不存在引发KeyError异常

和 __getitem__ 的访问类似，是设置值的方法

字典或其子类使用 __getitem__() 调用时，key不存在执行该方法

> **def \_\_missing\_\_(self, key):**
>
> **print(\'Missing key : \', key)**
>
> **return 0**
>
> **a = A()**
>
> **print(a\[\'k\'\])**

思考

为什么空字典、空字符串、空元组、空集合、空列表等可以等效为False？ 练习

将购物车类改造成方便操作的容器类



class Cart:

> **def \_\_init\_\_(self):**
>
> **self.items = \[\]**
>
> **def \_\_len\_\_(self):**
>
> **return len(self.items)**
>
> **def additem(self, item):**
>
> **self.items.append(item)**
>
> **def \_\_iter\_\_(self):**
>
> **\# yield from self.items**
>
> **return iter(self.items)**
>
> **def \_\_getitem\_\_(self, index): \# 索引访问 return self.items\[index\]**
>
> **def \_\_setitem\_\_(self, key, value): \# 索引赋值 self.items\[key\] = value**
>
> **def \_\_str\_\_(self):**
>
> **return str(self.items)**
>
> **def \_\_add\_\_(self, other): \# +**
>
> **self.items.append(other)**
>
> **return self**

cart = Cart()

cart.additem(1)

cart.additem('abc')

cart.additem(3)

# 长度、bool

print(len(cart))

print(bool(cart))

# 迭代

for x in cart:

> **print(x)**

# in

print(3 in cart)

print(2 in cart)

# 索引操作

print(cart[1])

cart[1] = 'xyz'

print(cart)

# 链式编程实现加法

print(cart + 4 + 5 + 6)

print(cart.__add__(17).__add__(18))



** **

可调用对象

Python中一切皆对象，函数也不例外。

> **def foo():**
>
> **print(foo.\_\_module\_\_, foo.\_\_name\_\_)**
>
> **foo()**
>
> **\# 等价于**
>
> **foo.\_\_call\_\_()**

函数即对象，对象foo加上()，就是调用此函数对象的 __call__() 方法 可调用对象

> **方法**
>
> **\_\_call\_\_**

意义

类中定义一个该方法，实例就可以像函数一样调用

> **可调用对象：定义一个类，并实例化得到其实例，将实例像函数一样调用。 class Point:**
>
> **def \_\_init\_\_(self, x, y):**
>
> **self.x = x**
>
> **self.y = y**
>
> **def \_\_call\_\_(self, \*args, \*\*kwargs):**
>
> **return \"\<Point {}:{}\>\".format(self.x, self.y)**
>
> **p = Point(4, 5)**
>
> **print(p)**
>
> **print(p())**
>
> **\# 累加**
>
> **class Adder:**
>
> **def \_\_call\_\_(self, \*args):**
>
> **ret = 0**
>
> **for x in args:**
>
> **ret += x**
>
> **self.ret = ret**
>
> **return ret**
>
> **adder = Adder()**
>
> **print(adder(4, 5, 6))**
>
> **print(adder.ret)**



练习：

定义一个斐波那契数列的类，方便调用，计算第n项。

增加迭代的方法、返回容器长度、支持索引的方法。

> **class Fib:**
>
> **def \_\_init\_\_(self):**
>
> **self.items = \[0, 1, 1\]**
>
> **def \_\_call\_\_(self, index):**
>
> **if index \< 0:**
>
> **raise IndexError(\'Wrong Index\')**
>
> **if index \< len(self.items):**
>
> **return self.items\[index\]**
>
> **for i in range(len(self.items), index+1):**
>
> **self.items.append(self.items\[i-1\] + self.items\[i-2\]) return self.items\[index\]**
>
> **print(Fib()(101))**

上例中，增加迭代的方法、返回容器长度、支持索引的方法

> **class Fib:**
>
> **def \_\_init\_\_(self):**
>
> **self.items = \[0, 1, 1\]**
>
> **def \_\_call\_\_(self, index):**
>
> **return self\[index\]**
>
> **def \_\_iter\_\_(self):**
>
> **return iter(self.items)**
>
> **def \_\_len\_\_(self):**
>
> **return len(self.items)**
>
> **def \_\_getitem\_\_(self, index):**
>
> **if index \< 0:**
>
> **raise IndexError(\'Wrong Index\')**
>
> **if index \< len(self.items):**
>
> **return self.items\[index\]**
>
> **for i in range(len(self), index+1):**
>
> **self.items.append(self.items\[i-1\] + self.items\[i-2\]) return self.items\[index\]**
>
> **def \_\_str\_\_(self):**
>
> **return str(self.items)**
>
> **\_\_repr\_\_ = \_\_str\_\_**
>
> fib = Fib()



> **print(fib(5), len(fib)) \# 全部计算**
>
> **print(fib(10), len(fib)) \# 部分计算**
>
> **for x in fib:**
>
> **print(x)**
>
> **print(fib\[5\], fib\[6\]) \# 索引访问，不计算**

可以看出使用类来实现斐波那契数列也是非常好的实现，还可以缓存数据，便于检索。
